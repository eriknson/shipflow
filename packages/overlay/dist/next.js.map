{"version":3,"sources":["../src/server/createNextHandler.ts","../src/server/undoManager.ts","../src/server/createUndoHandler.ts","../src/next.ts"],"sourcesContent":["import type { NextRequest } from \"next/server\";\nimport { NextResponse } from \"next/server\";\n\nimport type { StreamEvent } from \"../runtime/types\";\n// Import constants, including STREAM_HEADERS\nimport { STREAM_HEADERS } from \"../runtime/constants\";\nimport { undoManager } from \"./undoManager\";\n\nexport type ShipflowOverlayRequestPayload = {\n  filePath: string | null;\n  htmlFrame: string | null;\n  stackTrace: string | null;\n  instruction: string;\n  model?: string;\n};\n\nexport type ShipflowOverlayServerOptions = {\n  cursorAgentBinary?: string;\n  additionalSearchDirs?: string[];\n  defaultModel?: string;\n  allowInProduction?: boolean;\n  timeoutMs?: number;\n  logPrefix?: string;\n};\n\nconst DEFAULT_MODEL = \"composer-1\";\n\n// Edge-runtime-compatible path utilities (no Node.js path module required)\nconst isAbsolutePath = (p: string): boolean => {\n  // Unix absolute path\n  if (p.startsWith(\"/\")) return true;\n  // Windows absolute path (e.g., C:\\ or C:/)\n  if (/^[A-Za-z]:[\\\\/]/.test(p)) return true;\n  return false;\n};\n\nconst normalizeSeparators = (p: string): string => p.replace(/\\\\/g, \"/\");\n\nconst getRelativePath = (from: string, to: string): string => {\n  const fromParts = normalizeSeparators(from).split(\"/\").filter(Boolean);\n  const toParts = normalizeSeparators(to).split(\"/\").filter(Boolean);\n\n  // Find common prefix length\n  let commonLength = 0;\n  const minLength = Math.min(fromParts.length, toParts.length);\n  for (let i = 0; i < minLength; i++) {\n    if (fromParts[i] === toParts[i]) {\n      commonLength++;\n    } else {\n      break;\n    }\n  }\n\n  // Build relative path\n  const upCount = fromParts.length - commonLength;\n  const downParts = toParts.slice(commonLength);\n  const relativeParts = [...Array(upCount).fill(\"..\"), ...downParts];\n\n  return relativeParts.join(\"/\") || \".\";\n};\n\n// Multiple patterns to extract file paths from various stack trace formats\nconst STACK_TRACE_PATTERNS = [\n  // Format: \"in Component (path/to/file.tsx:10:5)\" or \"at Component (path/to/file.tsx:10:5)\"\n  /\\b(?:in|at)\\s+\\S+\\s*\\(([^()]+?\\.(?:[jt]sx?|mdx?))(?::\\d+)*\\)/gi,\n  // Format: \"in path/to/file.tsx\" or \"at path/to/file.tsx\"\n  /\\b(?:in|at)\\s+((?:[A-Za-z]:)?[^\\s:()]+?\\.(?:[jt]sx?|mdx?))/gi,\n  // Format: just \"(path/to/file.tsx:10:5)\" in parentheses\n  /\\(([^()]+?\\.(?:[jt]sx?|mdx?))(?::\\d+)*\\)/gi,\n  // Format: bare path like \"app/page.tsx\" without surrounding context\n  /(?:^|\\s)((?:\\.\\/)?(?:[A-Za-z]:)?[^\\s:()]+?\\.(?:[jt]sx?|mdx?))/gim,\n];\n\nconst normalizeFilePath = (filePath: string | null) => {\n  if (!filePath) return null;\n  const trimmed = filePath.trim();\n  if (!trimmed) return null;\n\n  const webpackPrefix = \"webpack-internal:///\";\n  const filePrefix = \"file://\";\n  let sanitized = trimmed;\n  if (sanitized.startsWith(webpackPrefix)) {\n    sanitized = sanitized.slice(webpackPrefix.length);\n  }\n  if (sanitized.startsWith(filePrefix)) {\n    sanitized = sanitized.slice(filePrefix.length);\n  }\n  if (sanitized.startsWith(\"./\")) {\n    sanitized = sanitized.slice(2);\n  }\n\n  if (!sanitized) {\n    return null;\n  }\n\n  const cwd = process.cwd();\n  if (pathIsAbsoluteSafe(sanitized)) {\n    const relative = relativeSafe(cwd, sanitized);\n    return relative.startsWith(\"..\") ? sanitized : relative;\n  }\n\n  return sanitized;\n};\n\nconst pathIsAbsoluteSafe = (target: string) => {\n  try {\n    return isAbsolutePath(target);\n  } catch {\n    return false;\n  }\n};\n\nconst relativeSafe = (from: string, to: string) => {\n  try {\n    return getRelativePath(from, to);\n  } catch {\n    return to;\n  }\n};\n\nconst extractFilePathFromStackTrace = (stackTrace: string | null) => {\n  if (!stackTrace) return null;\n\n  // Try each pattern in order of specificity\n  for (const pattern of STACK_TRACE_PATTERNS) {\n    pattern.lastIndex = 0;\n    let match: RegExpExecArray | null;\n\n    while ((match = pattern.exec(stackTrace))) {\n      const rawCandidate = match[1];\n      if (typeof rawCandidate !== \"string\") {\n        continue;\n      }\n\n      let candidate = rawCandidate.trim();\n      if (!candidate) {\n        continue;\n      }\n\n      // Skip node_modules paths\n      if (candidate.includes(\"node_modules/\") || candidate.includes(\"node_modules\\\\\")) {\n        continue;\n      }\n\n      // Skip URLs\n      if (candidate.includes(\"://\")) {\n        continue;\n      }\n\n      // Clean up webpack prefixes\n      if (candidate.startsWith(\"webpack-internal:///\")) {\n        candidate = candidate.slice(\"webpack-internal:///\".length);\n      }\n\n      // Clean up relative path prefix\n      if (candidate.startsWith(\"./\")) {\n        candidate = candidate.slice(2);\n      }\n\n      // Strip line/column numbers at the end (e.g., \":10:5\")\n      candidate = candidate.replace(/:\\d+(?::\\d+)?$/, \"\");\n\n      if (!candidate) {\n        continue;\n      }\n\n      return candidate;\n    }\n  }\n\n  return null;\n};\n\nconst extractComponentNames = (stackTrace: string | null): string[] => {\n  if (!stackTrace) return [];\n  // Match \"at ComponentName (Server)\" or \"in ComponentName (Server)\" - PascalCase components only\n  const matches = stackTrace.matchAll(/\\b(?:at|in)\\s+([A-Z][a-zA-Z0-9]*)\\s*\\(Server\\)/g);\n  return [...matches].map((m) => m[1]).filter(Boolean);\n};\n\nconst buildPrompt = (\n  filePath: string | null,\n  htmlFrame: string | null,\n  stackTrace: string | null,\n  instruction: string,\n) => {\n  const lines: string[] = [];\n\n  if (filePath) {\n    lines.push(`Open ${filePath}.`);\n    lines.push(\"Target the element matching this HTML:\");\n    lines.push(htmlFrame ?? \"(no HTML frame provided)\");\n    lines.push(\"\");\n    lines.push(\"and the component stack:\");\n    lines.push(stackTrace ?? \"(no component stack provided)\");\n  } else {\n    // Fallback for RSC or when file path cannot be determined\n    lines.push(\"Find the file containing the component that renders this HTML:\");\n    lines.push(htmlFrame ?? \"(no HTML frame provided)\");\n    lines.push(\"\");\n    lines.push(\"Component stack (use component names to locate the file):\");\n    lines.push(stackTrace ?? \"(no component stack provided)\");\n\n    const componentNames = extractComponentNames(stackTrace);\n    if (componentNames.length > 0) {\n      lines.push(\"\");\n      lines.push(`Look for files defining these components: ${componentNames.join(\", \")}`);\n    }\n  }\n\n  lines.push(\"\");\n  lines.push(`User request: ${instruction}`);\n  return lines.join(\"\\n\");\n};\n\nconst stripNullish = <T extends Record<string, unknown>>(record: T): T =>\n  Object.fromEntries(\n    Object.entries(record).filter(([, value]) => value !== undefined && value !== null),\n  ) as T;\n\nconst isEnabled = (options: ShipflowOverlayServerOptions): boolean => {\n  if (options.allowInProduction) {\n    return true;\n  }\n  const envFlag = process.env.SHIPFLOW_OVERLAY_ENABLED;\n  if (envFlag && [\"true\", \"1\", \"on\", \"yes\"].includes(envFlag.toLowerCase())) {\n    return true;\n  }\n  return process.env.NODE_ENV === \"development\";\n};\n\nexport function createNextHandler(options: ShipflowOverlayServerOptions = {}) {\n  const logPrefix = options.logPrefix ?? \"[shipflow-overlay]\";\n\n  return async function handler(request: NextRequest) {\n    if (!isEnabled(options)) {\n      return NextResponse.json(\n        { error: \"Shipflow overlay workflow is only available in development.\" },\n        { status: 403 },\n      );\n    }\n\n    let payload: ShipflowOverlayRequestPayload;\n    try {\n      payload = (await request.json()) as ShipflowOverlayRequestPayload;\n    } catch {\n      return NextResponse.json({ error: \"Invalid JSON payload.\" }, { status: 400 });\n    }\n\n    const instruction = payload.instruction?.trim();\n    if (!instruction) {\n      return NextResponse.json({ error: \"Instruction is required.\" }, { status: 400 });\n    }\n\n    const directFilePath = normalizeFilePath(payload.filePath);\n    const derivedFilePath =\n      directFilePath ??\n      (payload.filePath\n        ? null\n        : normalizeFilePath(extractFilePathFromStackTrace(payload.stackTrace)));\n    const normalizedFilePath = derivedFilePath;\n\n    if (!normalizedFilePath) {\n      const truncatedStack = payload.stackTrace?.slice(0, 200) ?? \"(none)\";\n      console.warn(\n        `${logPrefix} No file path found, using fallback prompt. stackTrace snippet: ${truncatedStack}`,\n      );\n    }\n\n    // buildPrompt handles null filePath with a discovery-focused fallback prompt\n    const prompt = buildPrompt(normalizedFilePath, payload.htmlFrame, payload.stackTrace, instruction);\n    const model = payload.model?.trim() || options.defaultModel || DEFAULT_MODEL;\n\n    try {\n      // Dynamically import the cursor agent implementation to avoid bundling Node.js dependencies\n      // (child_process, fs) in the initial bundle. This helps prevent errors in Edge environments\n      // where these modules are not available, even if this handler is only used in Node.js routes.\n      const { resolveCursorAgentBinary, runCursorAgentStream } = await import(\"./cursorAgent\");\n\n      const resolved = await resolveCursorAgentBinary(\n        stripNullish({\n          binaryPath: options.cursorAgentBinary,\n          additionalSearchDirs: options.additionalSearchDirs,\n          logPrefix,\n        }),\n      );\n\n      // Create undo session and capture workspace state\n      const cwd = process.cwd();\n      const sessionId = undoManager.createSession(instruction, normalizedFilePath);\n      \n      try {\n        await undoManager.captureWorkspace(sessionId, cwd);\n      } catch (error) {\n        console.warn(`${logPrefix} Failed to capture workspace for undo:`, error);\n      }\n\n      const encoder = new TextEncoder();\n\n      const stream = new ReadableStream({\n        async start(controller) {\n          const state = { isClosed: false };\n\n          const send = (event: StreamEvent) => {\n            if (state.isClosed) {\n              return;\n            }\n            try {\n              controller.enqueue(encoder.encode(`${JSON.stringify(event)}\\n`));\n            } catch (error) {\n              if (\n                error instanceof TypeError &&\n                (error.message.includes(\"closed\") || error.message.includes(\"Invalid state\"))\n              ) {\n                state.isClosed = true;\n              }\n            }\n          };\n\n          request.signal.addEventListener(\"abort\", () => {\n            state.isClosed = true;\n            try {\n              controller.close();\n            } catch {\n              // ignore\n            }\n          });\n\n          // Send session ID for undo support\n          send({ event: \"session\", sessionId });\n          send({ event: \"status\", message: \"Understanding user intent\" });\n\n          try {\n            await runCursorAgentStream(\n              {\n                binary: resolved.binary,\n                model,\n                prompt,\n                timeoutMs: options.timeoutMs,\n                logPrefix,\n                env: resolved.env,\n              },\n              send,\n            );\n          } catch (error) {\n            if (state.isClosed) {\n              return;\n            }\n            console.error(`${logPrefix} Failed during Cursor CLI streaming`, error);\n            send({\n              event: \"done\",\n              success: false,\n              summary: \"\",\n              exitCode: null,\n              error:\n                error instanceof Error\n                  ? error.message\n                  : \"Unexpected error streaming from Cursor CLI.\",\n            });\n          } finally {\n            if (!state.isClosed) {\n              try {\n                controller.close();\n              } catch {\n                // ignore\n              }\n              state.isClosed = true;\n            }\n          }\n        },\n      });\n\n      return new NextResponse(stream, {\n        headers: STREAM_HEADERS,\n      });\n    } catch (error) {\n      console.error(`${logPrefix} Failed to run cursor-agent`, error);\n      return NextResponse.json(\n        {\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Failed to invoke Cursor CLI. Ensure cursor-agent is installed and available on PATH.\",\n        },\n        { status: 500 },\n      );\n    }\n  };\n}\n","import { readFile, writeFile, unlink, readdir, stat } from \"fs/promises\";\nimport { join, relative, extname } from \"path\";\nimport { randomUUID } from \"crypto\";\n\nconst LOG_PREFIX = \"[shipflow-undo]\";\n\n// File extensions to capture\nconst SOURCE_EXTENSIONS = new Set([\n  \".ts\",\n  \".tsx\",\n  \".js\",\n  \".jsx\",\n  \".mjs\",\n  \".cjs\",\n  \".json\",\n  \".css\",\n  \".scss\",\n  \".sass\",\n  \".less\",\n  \".md\",\n  \".mdx\",\n  \".html\",\n]);\n\n// Directories to skip\nconst IGNORE_DIRS = new Set([\n  \"node_modules\",\n  \".next\",\n  \".git\",\n  \"dist\",\n  \"build\",\n  \".turbo\",\n  \".vercel\",\n  \"coverage\",\n  \".nyc_output\",\n  \"__pycache__\",\n  \".cache\",\n]);\n\n// File patterns to skip\nconst IGNORE_PATTERNS = [/\\.min\\./, /\\.d\\.ts$/, /\\.map$/];\n\n// Limits\nconst MAX_FILE_SIZE = 1 * 1024 * 1024; // 1MB per file\nconst MAX_SESSION_SIZE = 50 * 1024 * 1024; // 50MB total per session\nconst MAX_SESSIONS = 5;\n\nexport interface UndoSession {\n  id: string;\n  timestamp: number;\n  instruction: string;\n  filePath: string | null;\n  snapshots: Map<string, string | null>; // path -> content (null = didn't exist)\n  totalSize: number;\n}\n\nexport interface RestoreResult {\n  success: boolean;\n  restored: string[];\n  deleted: string[];\n  error?: string;\n}\n\nclass UndoManager {\n  private sessions: Map<string, UndoSession> = new Map();\n  private sessionOrder: string[] = []; // For FIFO eviction\n  private latestSessionId: string | null = null;\n\n  /**\n   * Create a new undo session\n   */\n  createSession(instruction: string, filePath: string | null): string {\n    const id = randomUUID();\n    const session: UndoSession = {\n      id,\n      timestamp: Date.now(),\n      instruction,\n      filePath,\n      snapshots: new Map(),\n      totalSize: 0,\n    };\n\n    this.sessions.set(id, session);\n    this.sessionOrder.push(id);\n    this.latestSessionId = id;\n\n    // Evict old sessions if we exceed the limit\n    while (this.sessionOrder.length > MAX_SESSIONS) {\n      const oldestId = this.sessionOrder.shift();\n      if (oldestId) {\n        this.sessions.delete(oldestId);\n        console.log(`${LOG_PREFIX} Evicted old session: ${oldestId}`);\n      }\n    }\n\n    console.log(`${LOG_PREFIX} Created session: ${id}`);\n    return id;\n  }\n\n  /**\n   * Capture the current state of all source files in the workspace\n   */\n  async captureWorkspace(sessionId: string, cwd: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n\n    console.log(`${LOG_PREFIX} Capturing workspace: ${cwd}`);\n    const startTime = Date.now();\n    let fileCount = 0;\n\n    try {\n      await this.walkDirectory(cwd, cwd, session);\n      fileCount = session.snapshots.size;\n    } catch (error) {\n      console.error(`${LOG_PREFIX} Error capturing workspace:`, error);\n      throw error;\n    }\n\n    const duration = Date.now() - startTime;\n    console.log(\n      `${LOG_PREFIX} Captured ${fileCount} files (${(session.totalSize / 1024).toFixed(1)}KB) in ${duration}ms`\n    );\n  }\n\n  /**\n   * Recursively walk directory and capture files\n   */\n  private async walkDirectory(\n    dir: string,\n    rootDir: string,\n    session: UndoSession\n  ): Promise<void> {\n    let entries;\n    try {\n      entries = await readdir(dir, { withFileTypes: true });\n    } catch {\n      // Directory might not be readable, skip it\n      return;\n    }\n\n    for (const entry of entries) {\n      const fullPath = join(dir, entry.name);\n\n      if (entry.isDirectory()) {\n        // Skip ignored directories\n        if (IGNORE_DIRS.has(entry.name)) {\n          continue;\n        }\n        await this.walkDirectory(fullPath, rootDir, session);\n      } else if (entry.isFile()) {\n        await this.captureFile(fullPath, rootDir, session);\n      }\n    }\n  }\n\n  /**\n   * Capture a single file if it matches our criteria\n   */\n  private async captureFile(\n    filePath: string,\n    rootDir: string,\n    session: UndoSession\n  ): Promise<void> {\n    // Check extension\n    const ext = extname(filePath).toLowerCase();\n    if (!SOURCE_EXTENSIONS.has(ext)) {\n      return;\n    }\n\n    // Check ignore patterns\n    const relativePath = relative(rootDir, filePath);\n    if (IGNORE_PATTERNS.some((pattern) => pattern.test(relativePath))) {\n      return;\n    }\n\n    // Check file size\n    let stats;\n    try {\n      stats = await stat(filePath);\n    } catch {\n      return;\n    }\n\n    if (stats.size > MAX_FILE_SIZE) {\n      console.log(`${LOG_PREFIX} Skipping large file: ${relativePath} (${(stats.size / 1024 / 1024).toFixed(1)}MB)`);\n      return;\n    }\n\n    // Check session size limit\n    if (session.totalSize + stats.size > MAX_SESSION_SIZE) {\n      console.warn(`${LOG_PREFIX} Session size limit reached, stopping capture`);\n      return;\n    }\n\n    // Read and store file content\n    try {\n      const content = await readFile(filePath, \"utf-8\");\n      session.snapshots.set(filePath, content);\n      session.totalSize += stats.size;\n    } catch (error) {\n      console.warn(`${LOG_PREFIX} Failed to read file: ${relativePath}`, error);\n    }\n  }\n\n  /**\n   * Restore workspace to the state captured in the session\n   */\n  async restoreSession(sessionId: string): Promise<RestoreResult> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      return {\n        success: false,\n        restored: [],\n        deleted: [],\n        error: `Session not found: ${sessionId}`,\n      };\n    }\n\n    console.log(`${LOG_PREFIX} Restoring session: ${sessionId}`);\n    const restored: string[] = [];\n    const deleted: string[] = [];\n    const errors: string[] = [];\n\n    for (const [filePath, originalContent] of session.snapshots) {\n      try {\n        if (originalContent === null) {\n          // File didn't exist before - delete it if it exists now\n          try {\n            await unlink(filePath);\n            deleted.push(filePath);\n            console.log(`${LOG_PREFIX} Deleted: ${filePath}`);\n          } catch {\n            // File might not exist anymore, that's fine\n          }\n        } else {\n          // Check if file has changed\n          let currentContent: string | null = null;\n          try {\n            currentContent = await readFile(filePath, \"utf-8\");\n          } catch {\n            // File might have been deleted\n          }\n\n          if (currentContent !== originalContent) {\n            await writeFile(filePath, originalContent, \"utf-8\");\n            restored.push(filePath);\n            console.log(`${LOG_PREFIX} Restored: ${filePath}`);\n          }\n        }\n      } catch (error) {\n        const msg = `Failed to restore ${filePath}: ${error instanceof Error ? error.message : String(error)}`;\n        errors.push(msg);\n        console.error(`${LOG_PREFIX} ${msg}`);\n      }\n    }\n\n    // Also check for new files created by the agent that weren't in our snapshot\n    // We need to detect these by comparing with current state\n    // For now, we only restore files we knew about\n\n    // Remove the session after restore\n    this.sessions.delete(sessionId);\n    const idx = this.sessionOrder.indexOf(sessionId);\n    if (idx !== -1) {\n      this.sessionOrder.splice(idx, 1);\n    }\n    if (this.latestSessionId === sessionId) {\n      this.latestSessionId = this.sessionOrder[this.sessionOrder.length - 1] ?? null;\n    }\n\n    console.log(\n      `${LOG_PREFIX} Restore complete: ${restored.length} restored, ${deleted.length} deleted`\n    );\n\n    return {\n      success: errors.length === 0,\n      restored,\n      deleted,\n      error: errors.length > 0 ? errors.join(\"; \") : undefined,\n    };\n  }\n\n  /**\n   * Get the latest session ID\n   */\n  getLatestSessionId(): string | null {\n    return this.latestSessionId;\n  }\n\n  /**\n   * Get session info (without full snapshots)\n   */\n  getSessionInfo(sessionId: string): Omit<UndoSession, \"snapshots\"> | null {\n    const session = this.sessions.get(sessionId);\n    if (!session) return null;\n\n    return {\n      id: session.id,\n      timestamp: session.timestamp,\n      instruction: session.instruction,\n      filePath: session.filePath,\n      totalSize: session.totalSize,\n    };\n  }\n\n  /**\n   * List all sessions\n   */\n  listSessions(): Array<Omit<UndoSession, \"snapshots\">> {\n    return this.sessionOrder.map((id) => {\n      const session = this.sessions.get(id)!;\n      return {\n        id: session.id,\n        timestamp: session.timestamp,\n        instruction: session.instruction,\n        filePath: session.filePath,\n        totalSize: session.totalSize,\n      };\n    });\n  }\n\n  /**\n   * Track a new file that was created during agent execution\n   * Call this when we detect a file was created that wasn't in our initial snapshot\n   */\n  trackNewFile(sessionId: string, filePath: string): void {\n    const session = this.sessions.get(sessionId);\n    if (!session) return;\n\n    if (!session.snapshots.has(filePath)) {\n      session.snapshots.set(filePath, null); // null means file didn't exist\n      console.log(`${LOG_PREFIX} Tracking new file: ${filePath}`);\n    }\n  }\n}\n\n// Singleton instance\nexport const undoManager = new UndoManager();\n","import type { NextRequest } from \"next/server\";\nimport { NextResponse } from \"next/server\";\n\nimport { undoManager } from \"./undoManager\";\n\nexport type ShipflowUndoRequestPayload = {\n  sessionId?: string;\n};\n\nexport type ShipflowUndoServerOptions = {\n  allowInProduction?: boolean;\n  logPrefix?: string;\n};\n\nconst isEnabled = (options: ShipflowUndoServerOptions): boolean => {\n  if (options.allowInProduction) {\n    return true;\n  }\n  const envFlag = process.env.SHIPFLOW_OVERLAY_ENABLED;\n  if (envFlag && [\"true\", \"1\", \"on\", \"yes\"].includes(envFlag.toLowerCase())) {\n    return true;\n  }\n  return process.env.NODE_ENV === \"development\";\n};\n\nexport function createUndoHandler(options: ShipflowUndoServerOptions = {}) {\n  const logPrefix = options.logPrefix ?? \"[shipflow-undo]\";\n\n  return async function handler(request: NextRequest) {\n    if (!isEnabled(options)) {\n      return NextResponse.json(\n        { error: \"Shipflow undo is only available in development.\" },\n        { status: 403 }\n      );\n    }\n\n    let payload: ShipflowUndoRequestPayload;\n    try {\n      payload = (await request.json()) as ShipflowUndoRequestPayload;\n    } catch {\n      // If no body, use latest session\n      payload = {};\n    }\n\n    const sessionId = payload.sessionId ?? undoManager.getLatestSessionId();\n\n    if (!sessionId) {\n      return NextResponse.json(\n        { error: \"No undo session available.\" },\n        { status: 404 }\n      );\n    }\n\n    console.log(`${logPrefix} Undo requested for session: ${sessionId}`);\n\n    try {\n      const result = await undoManager.restoreSession(sessionId);\n\n      if (!result.success) {\n        return NextResponse.json(\n          {\n            success: false,\n            error: result.error ?? \"Failed to restore session.\",\n            restored: result.restored,\n            deleted: result.deleted,\n          },\n          { status: 500 }\n        );\n      }\n\n      return NextResponse.json({\n        success: true,\n        restored: result.restored,\n        deleted: result.deleted,\n        message: `Restored ${result.restored.length} file(s), deleted ${result.deleted.length} file(s).`,\n      });\n    } catch (error) {\n      console.error(`${logPrefix} Undo failed:`, error);\n      return NextResponse.json(\n        {\n          success: false,\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Unexpected error during undo.\",\n        },\n        { status: 500 }\n      );\n    }\n  };\n}\n\n// Re-export undoManager for advanced use cases\nexport { undoManager } from \"./undoManager\";\n","import { createNextHandler, type ShipflowOverlayServerOptions } from \"./server/createNextHandler\";\n\ntype NextConfig = Record<string, unknown>;\n\nexport type ShipflowOverlayNextOptions = {\n  enableInProduction?: boolean;\n  reactGrabUrl?: string;\n  logClipboardEndpoint?: string;\n};\n\nexport function withShipflowOverlay<T extends NextConfig = NextConfig>(\n  config: T = {} as T,\n  options: ShipflowOverlayNextOptions = {},\n): T & NextConfig {\n  const enabled =\n    options.enableInProduction || process.env.NODE_ENV === \"development\";\n\n  const env: Record<string, string | undefined> = {\n    ...(config.env as Record<string, string | undefined> | undefined),\n    SHIPFLOW_OVERLAY_ENABLED: enabled ? \"true\" : \"false\",\n  };\n\n  if (options.reactGrabUrl) {\n    env.SHIPFLOW_OVERLAY_REACT_GRAB_URL = options.reactGrabUrl;\n  }\n\n  if (options.logClipboardEndpoint) {\n    env.SHIPFLOW_OVERLAY_LOG_ENDPOINT = options.logClipboardEndpoint;\n  }\n\n  const existingTranspile = Array.isArray(config.transpilePackages)\n    ? config.transpilePackages\n    : [];\n  const transpilePackages = Array.from(\n    new Set([...existingTranspile, \"@shipflow/overlay\"]),\n  );\n\n  return {\n    ...config,\n    env,\n    transpilePackages,\n  };\n}\n\nexport { createNextHandler, type ShipflowOverlayServerOptions };\nexport { createUndoHandler, type ShipflowUndoServerOptions } from \"./server/createUndoHandler\";\n\n\n\n"],"mappings":";;;;;AACA,SAAS,oBAAoB;;;ACD7B,SAAS,UAAU,WAAW,QAAQ,SAAS,YAAY;AAC3D,SAAS,MAAM,UAAU,eAAe;AACxC,SAAS,kBAAkB;AAE3B,IAAM,aAAa;AAGnB,IAAM,oBAAoB,oBAAI,IAAI;AAAA,EAChC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAGD,IAAM,cAAc,oBAAI,IAAI;AAAA,EAC1B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAGD,IAAM,kBAAkB,CAAC,WAAW,YAAY,QAAQ;AAGxD,IAAM,gBAAgB,IAAI,OAAO;AACjC,IAAM,mBAAmB,KAAK,OAAO;AACrC,IAAM,eAAe;AAkBrB,IAAM,cAAN,MAAkB;AAAA,EAAlB;AACE,SAAQ,WAAqC,oBAAI,IAAI;AACrD,SAAQ,eAAyB,CAAC;AAClC;AAAA,SAAQ,kBAAiC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKzC,cAAc,aAAqB,UAAiC;AAClE,UAAM,KAAK,WAAW;AACtB,UAAM,UAAuB;AAAA,MAC3B;AAAA,MACA,WAAW,KAAK,IAAI;AAAA,MACpB;AAAA,MACA;AAAA,MACA,WAAW,oBAAI,IAAI;AAAA,MACnB,WAAW;AAAA,IACb;AAEA,SAAK,SAAS,IAAI,IAAI,OAAO;AAC7B,SAAK,aAAa,KAAK,EAAE;AACzB,SAAK,kBAAkB;AAGvB,WAAO,KAAK,aAAa,SAAS,cAAc;AAC9C,YAAM,WAAW,KAAK,aAAa,MAAM;AACzC,UAAI,UAAU;AACZ,aAAK,SAAS,OAAO,QAAQ;AAC7B,gBAAQ,IAAI,GAAG,UAAU,yBAAyB,QAAQ,EAAE;AAAA,MAC9D;AAAA,IACF;AAEA,YAAQ,IAAI,GAAG,UAAU,qBAAqB,EAAE,EAAE;AAClD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,WAAmB,KAA4B;AACpE,UAAM,UAAU,KAAK,SAAS,IAAI,SAAS;AAC3C,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MAAM,sBAAsB,SAAS,EAAE;AAAA,IACnD;AAEA,YAAQ,IAAI,GAAG,UAAU,yBAAyB,GAAG,EAAE;AACvD,UAAM,YAAY,KAAK,IAAI;AAC3B,QAAI,YAAY;AAEhB,QAAI;AACF,YAAM,KAAK,cAAc,KAAK,KAAK,OAAO;AAC1C,kBAAY,QAAQ,UAAU;AAAA,IAChC,SAAS,OAAO;AACd,cAAQ,MAAM,GAAG,UAAU,+BAA+B,KAAK;AAC/D,YAAM;AAAA,IACR;AAEA,UAAM,WAAW,KAAK,IAAI,IAAI;AAC9B,YAAQ;AAAA,MACN,GAAG,UAAU,aAAa,SAAS,YAAY,QAAQ,YAAY,MAAM,QAAQ,CAAC,CAAC,UAAU,QAAQ;AAAA,IACvG;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,cACZ,KACA,SACA,SACe;AACf,QAAI;AACJ,QAAI;AACF,gBAAU,MAAM,QAAQ,KAAK,EAAE,eAAe,KAAK,CAAC;AAAA,IACtD,QAAQ;AAEN;AAAA,IACF;AAEA,eAAW,SAAS,SAAS;AAC3B,YAAM,WAAW,KAAK,KAAK,MAAM,IAAI;AAErC,UAAI,MAAM,YAAY,GAAG;AAEvB,YAAI,YAAY,IAAI,MAAM,IAAI,GAAG;AAC/B;AAAA,QACF;AACA,cAAM,KAAK,cAAc,UAAU,SAAS,OAAO;AAAA,MACrD,WAAW,MAAM,OAAO,GAAG;AACzB,cAAM,KAAK,YAAY,UAAU,SAAS,OAAO;AAAA,MACnD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,YACZ,UACA,SACA,SACe;AAEf,UAAM,MAAM,QAAQ,QAAQ,EAAE,YAAY;AAC1C,QAAI,CAAC,kBAAkB,IAAI,GAAG,GAAG;AAC/B;AAAA,IACF;AAGA,UAAM,eAAe,SAAS,SAAS,QAAQ;AAC/C,QAAI,gBAAgB,KAAK,CAAC,YAAY,QAAQ,KAAK,YAAY,CAAC,GAAG;AACjE;AAAA,IACF;AAGA,QAAI;AACJ,QAAI;AACF,cAAQ,MAAM,KAAK,QAAQ;AAAA,IAC7B,QAAQ;AACN;AAAA,IACF;AAEA,QAAI,MAAM,OAAO,eAAe;AAC9B,cAAQ,IAAI,GAAG,UAAU,yBAAyB,YAAY,MAAM,MAAM,OAAO,OAAO,MAAM,QAAQ,CAAC,CAAC,KAAK;AAC7G;AAAA,IACF;AAGA,QAAI,QAAQ,YAAY,MAAM,OAAO,kBAAkB;AACrD,cAAQ,KAAK,GAAG,UAAU,+CAA+C;AACzE;AAAA,IACF;AAGA,QAAI;AACF,YAAM,UAAU,MAAM,SAAS,UAAU,OAAO;AAChD,cAAQ,UAAU,IAAI,UAAU,OAAO;AACvC,cAAQ,aAAa,MAAM;AAAA,IAC7B,SAAS,OAAO;AACd,cAAQ,KAAK,GAAG,UAAU,yBAAyB,YAAY,IAAI,KAAK;AAAA,IAC1E;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,WAA2C;AAjNlE;AAkNI,UAAM,UAAU,KAAK,SAAS,IAAI,SAAS;AAC3C,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,QACL,SAAS;AAAA,QACT,UAAU,CAAC;AAAA,QACX,SAAS,CAAC;AAAA,QACV,OAAO,sBAAsB,SAAS;AAAA,MACxC;AAAA,IACF;AAEA,YAAQ,IAAI,GAAG,UAAU,uBAAuB,SAAS,EAAE;AAC3D,UAAM,WAAqB,CAAC;AAC5B,UAAM,UAAoB,CAAC;AAC3B,UAAM,SAAmB,CAAC;AAE1B,eAAW,CAAC,UAAU,eAAe,KAAK,QAAQ,WAAW;AAC3D,UAAI;AACF,YAAI,oBAAoB,MAAM;AAE5B,cAAI;AACF,kBAAM,OAAO,QAAQ;AACrB,oBAAQ,KAAK,QAAQ;AACrB,oBAAQ,IAAI,GAAG,UAAU,aAAa,QAAQ,EAAE;AAAA,UAClD,QAAQ;AAAA,UAER;AAAA,QACF,OAAO;AAEL,cAAI,iBAAgC;AACpC,cAAI;AACF,6BAAiB,MAAM,SAAS,UAAU,OAAO;AAAA,UACnD,QAAQ;AAAA,UAER;AAEA,cAAI,mBAAmB,iBAAiB;AACtC,kBAAM,UAAU,UAAU,iBAAiB,OAAO;AAClD,qBAAS,KAAK,QAAQ;AACtB,oBAAQ,IAAI,GAAG,UAAU,cAAc,QAAQ,EAAE;AAAA,UACnD;AAAA,QACF;AAAA,MACF,SAAS,OAAO;AACd,cAAM,MAAM,qBAAqB,QAAQ,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AACpG,eAAO,KAAK,GAAG;AACf,gBAAQ,MAAM,GAAG,UAAU,IAAI,GAAG,EAAE;AAAA,MACtC;AAAA,IACF;AAOA,SAAK,SAAS,OAAO,SAAS;AAC9B,UAAM,MAAM,KAAK,aAAa,QAAQ,SAAS;AAC/C,QAAI,QAAQ,IAAI;AACd,WAAK,aAAa,OAAO,KAAK,CAAC;AAAA,IACjC;AACA,QAAI,KAAK,oBAAoB,WAAW;AACtC,WAAK,mBAAkB,UAAK,aAAa,KAAK,aAAa,SAAS,CAAC,MAA9C,YAAmD;AAAA,IAC5E;AAEA,YAAQ;AAAA,MACN,GAAG,UAAU,sBAAsB,SAAS,MAAM,cAAc,QAAQ,MAAM;AAAA,IAChF;AAEA,WAAO;AAAA,MACL,SAAS,OAAO,WAAW;AAAA,MAC3B;AAAA,MACA;AAAA,MACA,OAAO,OAAO,SAAS,IAAI,OAAO,KAAK,IAAI,IAAI;AAAA,IACjD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAoC;AAClC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,WAA0D;AACvE,UAAM,UAAU,KAAK,SAAS,IAAI,SAAS;AAC3C,QAAI,CAAC,QAAS,QAAO;AAErB,WAAO;AAAA,MACL,IAAI,QAAQ;AAAA,MACZ,WAAW,QAAQ;AAAA,MACnB,aAAa,QAAQ;AAAA,MACrB,UAAU,QAAQ;AAAA,MAClB,WAAW,QAAQ;AAAA,IACrB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,eAAsD;AACpD,WAAO,KAAK,aAAa,IAAI,CAAC,OAAO;AACnC,YAAM,UAAU,KAAK,SAAS,IAAI,EAAE;AACpC,aAAO;AAAA,QACL,IAAI,QAAQ;AAAA,QACZ,WAAW,QAAQ;AAAA,QACnB,aAAa,QAAQ;AAAA,QACrB,UAAU,QAAQ;AAAA,QAClB,WAAW,QAAQ;AAAA,MACrB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa,WAAmB,UAAwB;AACtD,UAAM,UAAU,KAAK,SAAS,IAAI,SAAS;AAC3C,QAAI,CAAC,QAAS;AAEd,QAAI,CAAC,QAAQ,UAAU,IAAI,QAAQ,GAAG;AACpC,cAAQ,UAAU,IAAI,UAAU,IAAI;AACpC,cAAQ,IAAI,GAAG,UAAU,uBAAuB,QAAQ,EAAE;AAAA,IAC5D;AAAA,EACF;AACF;AAGO,IAAM,cAAc,IAAI,YAAY;;;AD1T3C,IAAM,gBAAgB;AAGtB,IAAM,iBAAiB,CAAC,MAAuB;AAE7C,MAAI,EAAE,WAAW,GAAG,EAAG,QAAO;AAE9B,MAAI,kBAAkB,KAAK,CAAC,EAAG,QAAO;AACtC,SAAO;AACT;AAEA,IAAM,sBAAsB,CAAC,MAAsB,EAAE,QAAQ,OAAO,GAAG;AAEvE,IAAM,kBAAkB,CAAC,MAAc,OAAuB;AAC5D,QAAM,YAAY,oBAAoB,IAAI,EAAE,MAAM,GAAG,EAAE,OAAO,OAAO;AACrE,QAAM,UAAU,oBAAoB,EAAE,EAAE,MAAM,GAAG,EAAE,OAAO,OAAO;AAGjE,MAAI,eAAe;AACnB,QAAM,YAAY,KAAK,IAAI,UAAU,QAAQ,QAAQ,MAAM;AAC3D,WAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,QAAI,UAAU,CAAC,MAAM,QAAQ,CAAC,GAAG;AAC/B;AAAA,IACF,OAAO;AACL;AAAA,IACF;AAAA,EACF;AAGA,QAAM,UAAU,UAAU,SAAS;AACnC,QAAM,YAAY,QAAQ,MAAM,YAAY;AAC5C,QAAM,gBAAgB,CAAC,GAAG,MAAM,OAAO,EAAE,KAAK,IAAI,GAAG,GAAG,SAAS;AAEjE,SAAO,cAAc,KAAK,GAAG,KAAK;AACpC;AAGA,IAAM,uBAAuB;AAAA;AAAA,EAE3B;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AACF;AAEA,IAAM,oBAAoB,CAAC,aAA4B;AACrD,MAAI,CAAC,SAAU,QAAO;AACtB,QAAM,UAAU,SAAS,KAAK;AAC9B,MAAI,CAAC,QAAS,QAAO;AAErB,QAAM,gBAAgB;AACtB,QAAM,aAAa;AACnB,MAAI,YAAY;AAChB,MAAI,UAAU,WAAW,aAAa,GAAG;AACvC,gBAAY,UAAU,MAAM,cAAc,MAAM;AAAA,EAClD;AACA,MAAI,UAAU,WAAW,UAAU,GAAG;AACpC,gBAAY,UAAU,MAAM,WAAW,MAAM;AAAA,EAC/C;AACA,MAAI,UAAU,WAAW,IAAI,GAAG;AAC9B,gBAAY,UAAU,MAAM,CAAC;AAAA,EAC/B;AAEA,MAAI,CAAC,WAAW;AACd,WAAO;AAAA,EACT;AAEA,QAAM,MAAM,QAAQ,IAAI;AACxB,MAAI,mBAAmB,SAAS,GAAG;AACjC,UAAMA,YAAW,aAAa,KAAK,SAAS;AAC5C,WAAOA,UAAS,WAAW,IAAI,IAAI,YAAYA;AAAA,EACjD;AAEA,SAAO;AACT;AAEA,IAAM,qBAAqB,CAAC,WAAmB;AAC7C,MAAI;AACF,WAAO,eAAe,MAAM;AAAA,EAC9B,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEA,IAAM,eAAe,CAAC,MAAc,OAAe;AACjD,MAAI;AACF,WAAO,gBAAgB,MAAM,EAAE;AAAA,EACjC,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEA,IAAM,gCAAgC,CAAC,eAA8B;AACnE,MAAI,CAAC,WAAY,QAAO;AAGxB,aAAW,WAAW,sBAAsB;AAC1C,YAAQ,YAAY;AACpB,QAAI;AAEJ,WAAQ,QAAQ,QAAQ,KAAK,UAAU,GAAI;AACzC,YAAM,eAAe,MAAM,CAAC;AAC5B,UAAI,OAAO,iBAAiB,UAAU;AACpC;AAAA,MACF;AAEA,UAAI,YAAY,aAAa,KAAK;AAClC,UAAI,CAAC,WAAW;AACd;AAAA,MACF;AAGA,UAAI,UAAU,SAAS,eAAe,KAAK,UAAU,SAAS,gBAAgB,GAAG;AAC/E;AAAA,MACF;AAGA,UAAI,UAAU,SAAS,KAAK,GAAG;AAC7B;AAAA,MACF;AAGA,UAAI,UAAU,WAAW,sBAAsB,GAAG;AAChD,oBAAY,UAAU,MAAM,uBAAuB,MAAM;AAAA,MAC3D;AAGA,UAAI,UAAU,WAAW,IAAI,GAAG;AAC9B,oBAAY,UAAU,MAAM,CAAC;AAAA,MAC/B;AAGA,kBAAY,UAAU,QAAQ,kBAAkB,EAAE;AAElD,UAAI,CAAC,WAAW;AACd;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,wBAAwB,CAAC,eAAwC;AACrE,MAAI,CAAC,WAAY,QAAO,CAAC;AAEzB,QAAM,UAAU,WAAW,SAAS,iDAAiD;AACrF,SAAO,CAAC,GAAG,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,OAAO,OAAO;AACrD;AAEA,IAAM,cAAc,CAClB,UACA,WACA,YACA,gBACG;AACH,QAAM,QAAkB,CAAC;AAEzB,MAAI,UAAU;AACZ,UAAM,KAAK,QAAQ,QAAQ,GAAG;AAC9B,UAAM,KAAK,wCAAwC;AACnD,UAAM,KAAK,gCAAa,0BAA0B;AAClD,UAAM,KAAK,EAAE;AACb,UAAM,KAAK,0BAA0B;AACrC,UAAM,KAAK,kCAAc,+BAA+B;AAAA,EAC1D,OAAO;AAEL,UAAM,KAAK,gEAAgE;AAC3E,UAAM,KAAK,gCAAa,0BAA0B;AAClD,UAAM,KAAK,EAAE;AACb,UAAM,KAAK,2DAA2D;AACtE,UAAM,KAAK,kCAAc,+BAA+B;AAExD,UAAM,iBAAiB,sBAAsB,UAAU;AACvD,QAAI,eAAe,SAAS,GAAG;AAC7B,YAAM,KAAK,EAAE;AACb,YAAM,KAAK,6CAA6C,eAAe,KAAK,IAAI,CAAC,EAAE;AAAA,IACrF;AAAA,EACF;AAEA,QAAM,KAAK,EAAE;AACb,QAAM,KAAK,iBAAiB,WAAW,EAAE;AACzC,SAAO,MAAM,KAAK,IAAI;AACxB;AAEA,IAAM,eAAe,CAAoC,WACvD,OAAO;AAAA,EACL,OAAO,QAAQ,MAAM,EAAE,OAAO,CAAC,CAAC,EAAE,KAAK,MAAM,UAAU,UAAa,UAAU,IAAI;AACpF;AAEF,IAAM,YAAY,CAAC,YAAmD;AACpE,MAAI,QAAQ,mBAAmB;AAC7B,WAAO;AAAA,EACT;AACA,QAAM,UAAU,QAAQ,IAAI;AAC5B,MAAI,WAAW,CAAC,QAAQ,KAAK,MAAM,KAAK,EAAE,SAAS,QAAQ,YAAY,CAAC,GAAG;AACzE,WAAO;AAAA,EACT;AACA,SAAO,QAAQ,IAAI,aAAa;AAClC;AAEO,SAAS,kBAAkB,UAAwC,CAAC,GAAG;AAvO9E;AAwOE,QAAM,aAAY,aAAQ,cAAR,YAAqB;AAEvC,SAAO,eAAe,QAAQ,SAAsB;AA1OtD,QAAAC,KAAA;AA2OI,QAAI,CAAC,UAAU,OAAO,GAAG;AACvB,aAAO,aAAa;AAAA,QAClB,EAAE,OAAO,8DAA8D;AAAA,QACvE,EAAE,QAAQ,IAAI;AAAA,MAChB;AAAA,IACF;AAEA,QAAI;AACJ,QAAI;AACF,gBAAW,MAAM,QAAQ,KAAK;AAAA,IAChC,QAAQ;AACN,aAAO,aAAa,KAAK,EAAE,OAAO,wBAAwB,GAAG,EAAE,QAAQ,IAAI,CAAC;AAAA,IAC9E;AAEA,UAAM,eAAcA,MAAA,QAAQ,gBAAR,gBAAAA,IAAqB;AACzC,QAAI,CAAC,aAAa;AAChB,aAAO,aAAa,KAAK,EAAE,OAAO,2BAA2B,GAAG,EAAE,QAAQ,IAAI,CAAC;AAAA,IACjF;AAEA,UAAM,iBAAiB,kBAAkB,QAAQ,QAAQ;AACzD,UAAM,kBACJ,0CACC,QAAQ,WACL,OACA,kBAAkB,8BAA8B,QAAQ,UAAU,CAAC;AACzE,UAAM,qBAAqB;AAE3B,QAAI,CAAC,oBAAoB;AACvB,YAAM,kBAAiB,mBAAQ,eAAR,mBAAoB,MAAM,GAAG,SAA7B,YAAqC;AAC5D,cAAQ;AAAA,QACN,GAAG,SAAS,mEAAmE,cAAc;AAAA,MAC/F;AAAA,IACF;AAGA,UAAM,SAAS,YAAY,oBAAoB,QAAQ,WAAW,QAAQ,YAAY,WAAW;AACjG,UAAM,UAAQ,aAAQ,UAAR,mBAAe,WAAU,QAAQ,gBAAgB;AAE/D,QAAI;AAIF,YAAM,EAAE,0BAA0B,qBAAqB,IAAI,MAAM,OAAO,2BAAe;AAEvF,YAAM,WAAW,MAAM;AAAA,QACrB,aAAa;AAAA,UACX,YAAY,QAAQ;AAAA,UACpB,sBAAsB,QAAQ;AAAA,UAC9B;AAAA,QACF,CAAC;AAAA,MACH;AAGA,YAAM,MAAM,QAAQ,IAAI;AACxB,YAAM,YAAY,YAAY,cAAc,aAAa,kBAAkB;AAE3E,UAAI;AACF,cAAM,YAAY,iBAAiB,WAAW,GAAG;AAAA,MACnD,SAAS,OAAO;AACd,gBAAQ,KAAK,GAAG,SAAS,0CAA0C,KAAK;AAAA,MAC1E;AAEA,YAAM,UAAU,IAAI,YAAY;AAEhC,YAAM,SAAS,IAAI,eAAe;AAAA,QAChC,MAAM,MAAM,YAAY;AACtB,gBAAM,QAAQ,EAAE,UAAU,MAAM;AAEhC,gBAAM,OAAO,CAAC,UAAuB;AACnC,gBAAI,MAAM,UAAU;AAClB;AAAA,YACF;AACA,gBAAI;AACF,yBAAW,QAAQ,QAAQ,OAAO,GAAG,KAAK,UAAU,KAAK,CAAC;AAAA,CAAI,CAAC;AAAA,YACjE,SAAS,OAAO;AACd,kBACE,iBAAiB,cAChB,MAAM,QAAQ,SAAS,QAAQ,KAAK,MAAM,QAAQ,SAAS,eAAe,IAC3E;AACA,sBAAM,WAAW;AAAA,cACnB;AAAA,YACF;AAAA,UACF;AAEA,kBAAQ,OAAO,iBAAiB,SAAS,MAAM;AAC7C,kBAAM,WAAW;AACjB,gBAAI;AACF,yBAAW,MAAM;AAAA,YACnB,QAAQ;AAAA,YAER;AAAA,UACF,CAAC;AAGD,eAAK,EAAE,OAAO,WAAW,UAAU,CAAC;AACpC,eAAK,EAAE,OAAO,UAAU,SAAS,4BAA4B,CAAC;AAE9D,cAAI;AACF,kBAAM;AAAA,cACJ;AAAA,gBACE,QAAQ,SAAS;AAAA,gBACjB;AAAA,gBACA;AAAA,gBACA,WAAW,QAAQ;AAAA,gBACnB;AAAA,gBACA,KAAK,SAAS;AAAA,cAChB;AAAA,cACA;AAAA,YACF;AAAA,UACF,SAAS,OAAO;AACd,gBAAI,MAAM,UAAU;AAClB;AAAA,YACF;AACA,oBAAQ,MAAM,GAAG,SAAS,uCAAuC,KAAK;AACtE,iBAAK;AAAA,cACH,OAAO;AAAA,cACP,SAAS;AAAA,cACT,SAAS;AAAA,cACT,UAAU;AAAA,cACV,OACE,iBAAiB,QACb,MAAM,UACN;AAAA,YACR,CAAC;AAAA,UACH,UAAE;AACA,gBAAI,CAAC,MAAM,UAAU;AACnB,kBAAI;AACF,2BAAW,MAAM;AAAA,cACnB,QAAQ;AAAA,cAER;AACA,oBAAM,WAAW;AAAA,YACnB;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAED,aAAO,IAAI,aAAa,QAAQ;AAAA,QAC9B,SAAS;AAAA,MACX,CAAC;AAAA,IACH,SAAS,OAAO;AACd,cAAQ,MAAM,GAAG,SAAS,+BAA+B,KAAK;AAC9D,aAAO,aAAa;AAAA,QAClB;AAAA,UACE,OACE,iBAAiB,QACb,MAAM,UACN;AAAA,QACR;AAAA,QACA,EAAE,QAAQ,IAAI;AAAA,MAChB;AAAA,IACF;AAAA,EACF;AACF;;;AEnYA,SAAS,gBAAAC,qBAAoB;AAa7B,IAAMC,aAAY,CAAC,YAAgD;AACjE,MAAI,QAAQ,mBAAmB;AAC7B,WAAO;AAAA,EACT;AACA,QAAM,UAAU,QAAQ,IAAI;AAC5B,MAAI,WAAW,CAAC,QAAQ,KAAK,MAAM,KAAK,EAAE,SAAS,QAAQ,YAAY,CAAC,GAAG;AACzE,WAAO;AAAA,EACT;AACA,SAAO,QAAQ,IAAI,aAAa;AAClC;AAEO,SAAS,kBAAkB,UAAqC,CAAC,GAAG;AAzB3E;AA0BE,QAAM,aAAY,aAAQ,cAAR,YAAqB;AAEvC,SAAO,eAAe,QAAQ,SAAsB;AA5BtD,QAAAC,KAAA;AA6BI,QAAI,CAACD,WAAU,OAAO,GAAG;AACvB,aAAOE,cAAa;AAAA,QAClB,EAAE,OAAO,kDAAkD;AAAA,QAC3D,EAAE,QAAQ,IAAI;AAAA,MAChB;AAAA,IACF;AAEA,QAAI;AACJ,QAAI;AACF,gBAAW,MAAM,QAAQ,KAAK;AAAA,IAChC,QAAQ;AAEN,gBAAU,CAAC;AAAA,IACb;AAEA,UAAM,aAAYD,MAAA,QAAQ,cAAR,OAAAA,MAAqB,YAAY,mBAAmB;AAEtE,QAAI,CAAC,WAAW;AACd,aAAOC,cAAa;AAAA,QAClB,EAAE,OAAO,6BAA6B;AAAA,QACtC,EAAE,QAAQ,IAAI;AAAA,MAChB;AAAA,IACF;AAEA,YAAQ,IAAI,GAAG,SAAS,gCAAgC,SAAS,EAAE;AAEnE,QAAI;AACF,YAAM,SAAS,MAAM,YAAY,eAAe,SAAS;AAEzD,UAAI,CAAC,OAAO,SAAS;AACnB,eAAOA,cAAa;AAAA,UAClB;AAAA,YACE,SAAS;AAAA,YACT,QAAO,YAAO,UAAP,YAAgB;AAAA,YACvB,UAAU,OAAO;AAAA,YACjB,SAAS,OAAO;AAAA,UAClB;AAAA,UACA,EAAE,QAAQ,IAAI;AAAA,QAChB;AAAA,MACF;AAEA,aAAOA,cAAa,KAAK;AAAA,QACvB,SAAS;AAAA,QACT,UAAU,OAAO;AAAA,QACjB,SAAS,OAAO;AAAA,QAChB,SAAS,YAAY,OAAO,SAAS,MAAM,qBAAqB,OAAO,QAAQ,MAAM;AAAA,MACvF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,cAAQ,MAAM,GAAG,SAAS,iBAAiB,KAAK;AAChD,aAAOA,cAAa;AAAA,QAClB;AAAA,UACE,SAAS;AAAA,UACT,OACE,iBAAiB,QACb,MAAM,UACN;AAAA,QACR;AAAA,QACA,EAAE,QAAQ,IAAI;AAAA,MAChB;AAAA,IACF;AAAA,EACF;AACF;;;AChFO,SAAS,oBACd,SAAY,CAAC,GACb,UAAsC,CAAC,GACvB;AAChB,QAAM,UACJ,QAAQ,sBAAsB,QAAQ,IAAI,aAAa;AAEzD,QAAM,MAA0C;AAAA,IAC9C,GAAI,OAAO;AAAA,IACX,0BAA0B,UAAU,SAAS;AAAA,EAC/C;AAEA,MAAI,QAAQ,cAAc;AACxB,QAAI,kCAAkC,QAAQ;AAAA,EAChD;AAEA,MAAI,QAAQ,sBAAsB;AAChC,QAAI,gCAAgC,QAAQ;AAAA,EAC9C;AAEA,QAAM,oBAAoB,MAAM,QAAQ,OAAO,iBAAiB,IAC5D,OAAO,oBACP,CAAC;AACL,QAAM,oBAAoB,MAAM;AAAA,IAC9B,oBAAI,IAAI,CAAC,GAAG,mBAAmB,mBAAmB,CAAC;AAAA,EACrD;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH;AAAA,IACA;AAAA,EACF;AACF;","names":["relative","_a","NextResponse","isEnabled","_a","NextResponse"]}