{"version":3,"sources":["../src/server/cursorAgent.ts","../src/next.ts","../src/server/createNextHandler.ts","../src/runtime/constants.ts","../src/server/undoManager.ts","../src/server/createUndoHandler.ts"],"sourcesContent":["import { spawn, spawnSync } from \"child_process\";\nimport { access } from \"fs/promises\";\nimport { constants as fsConstants } from \"fs\";\nimport path from \"path\";\n\nimport type { StreamEvent } from \"../runtime/types\";\n\nconst LOG_PREFIX = \"[shipflow-overlay]\";\nconst CURSOR_BINARY_HINT = process.env.CURSOR_AGENT_BIN ?? \"cursor-agent\";\nconst HOME_DIR = process.env.HOME ?? process.env.USERPROFILE ?? \"\";\n\ntype ResolveOptions = {\n  binaryPath?: string;\n  additionalSearchDirs?: string[];\n  logPrefix?: string;\n};\n\ntype ResolvedBinary = {\n  binary: string;\n  env: NodeJS.ProcessEnv | null;\n};\n\ntype RunOptions = {\n  binary: string;\n  model: string;\n  prompt: string;\n  timeoutMs?: number;\n  logPrefix?: string;\n  env?: NodeJS.ProcessEnv | null;\n};\n\nlet cachedBinary: string | null = null;\nlet cachedEnv: NodeJS.ProcessEnv | null = null;\nlet resolvePromise: Promise<ResolvedBinary> | null = null;\n\nconst IGNORED_STATUS_MESSAGES = new Set([\"User event\"]);\n\nconst WHITELISTED_STATUS_MESSAGES = new Set([\n  \"Initializing agent\",\n  \"Agent ready.\",\n  \"Thinking\",\n  \"Building changes\",\n  \"Analyzing project\",\n  \"Build step complete.\",\n]);\n\nconst MIN_STATUS_LENGTH = 30;\nconst STATUS_KEYS = [\"text\", \"value\", \"delta\", \"message\", \"summary\", \"label\"];\n\nconst STREAM_HEADERS = {\n  \"Content-Type\": \"application/x-ndjson; charset=utf-8\",\n  \"Cache-Control\": \"no-cache, no-transform\",\n};\n\nexport { STREAM_HEADERS };\n\nconst pathExistsAndExecutable = async (filePath: string) => {\n  if (!filePath) return false;\n  try {\n    await access(filePath, fsConstants.X_OK);\n    return true;\n  } catch {\n    try {\n      await access(filePath, fsConstants.F_OK);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n};\n\nconst describeEvent = (event: unknown): string | null => {\n  if (!event || typeof event !== \"object\") {\n    return null;\n  }\n\n  const payload = event as Record<string, unknown>;\n  const type = typeof payload.type === \"string\" ? payload.type : null;\n  const subtype = typeof payload.subtype === \"string\" ? payload.subtype : null;\n\n  if (type === \"system\") {\n    if (subtype === \"init\") {\n      return \"Initializing agent\";\n    }\n    if (subtype === \"progress\" && typeof payload.message === \"string\") {\n      return payload.message;\n    }\n    if (subtype === \"completed\") {\n      return \"Agent ready.\";\n    }\n    return subtype ? `System update: ${subtype}` : \"System update.\";\n  }\n\n  if (type === \"assistant\") {\n    return \"Thinking…\";\n  }\n\n  if (type === \"tool_call\") {\n    const toolName =\n      typeof payload.tool === \"object\" &&\n      payload.tool &&\n      typeof (payload.tool as Record<string, unknown>).name === \"string\"\n        ? String((payload.tool as Record<string, unknown>).name)\n        : \"Tool\";\n    const normalizedName = toolName.toLowerCase();\n\n    if (subtype === \"started\") {\n      if (\n        normalizedName.includes(\"apply\") ||\n        normalizedName.includes(\"write\") ||\n        normalizedName.includes(\"patch\") ||\n        normalizedName.includes(\"build\")\n      ) {\n        return \"Building changes…\";\n      }\n      if (normalizedName.includes(\"plan\") || normalizedName.includes(\"analy\")) {\n        return \"Analyzing project…\";\n      }\n      return `Running ${toolName}…`;\n    }\n    if (subtype === \"completed\") {\n      if (\n        normalizedName.includes(\"apply\") ||\n        normalizedName.includes(\"write\") ||\n        normalizedName.includes(\"patch\") ||\n        normalizedName.includes(\"build\")\n      ) {\n        return \"Build step complete.\";\n      }\n      return `${toolName} finished.`;\n    }\n    return `${toolName} ${subtype ?? \"update\"}…`;\n  }\n\n  if (type === \"result\") {\n    return \"Finalizing changes…\";\n  }\n\n  if (type === \"error\") {\n    if (typeof payload.message === \"string\") {\n      return `Error: ${payload.message}`;\n    }\n    return \"Cursor CLI reported an error.\";\n  }\n\n  if (typeof payload.message === \"string\") {\n    return payload.message;\n  }\n\n  return type ? `Event: ${type}${subtype ? `/${subtype}` : \"\"}` : null;\n};\n\nconst extractAssistantText = (input: unknown, seen = new WeakSet<object>()): string => {\n  if (!input) return \"\";\n  if (typeof input === \"string\") {\n    return input;\n  }\n  if (Array.isArray(input)) {\n    return input.map((entry) => extractAssistantText(entry, seen)).join(\"\");\n  }\n  if (typeof input === \"object\") {\n    if (seen.has(input as object)) return \"\";\n    seen.add(input as object);\n\n    const record = input as Record<string, unknown>;\n    let text = \"\";\n\n    for (const key of STATUS_KEYS) {\n      const value = record[key];\n      if (typeof value === \"string\") {\n        text += value;\n      } else if (value) {\n        text += extractAssistantText(value, seen);\n      }\n    }\n\n    if (\"content\" in record) {\n      text += extractAssistantText(record.content, seen);\n    }\n    if (\"parts\" in record) {\n      text += extractAssistantText(record.parts, seen);\n    }\n    if (\"text_delta\" in record) {\n      text += extractAssistantText(record.text_delta, seen);\n    }\n\n    return text;\n  }\n  return \"\";\n};\n\nconst buildCandidateDirs = (binaryPath: string | undefined, additionalSearchDirs: string[]) => {\n  const candidateDirs = new Set<string>(\n    (process.env.PATH ?? \"\")\n      .split(path.delimiter)\n      .map((entry) => entry.trim())\n      .filter(Boolean),\n  );\n\n  for (const dir of additionalSearchDirs) {\n    if (dir) {\n      candidateDirs.add(dir);\n    }\n  }\n\n  if (HOME_DIR) {\n    candidateDirs.add(path.join(HOME_DIR, \".cursor\", \"bin\"));\n    candidateDirs.add(path.join(HOME_DIR, \"Library\", \"Application Support\", \"Cursor\", \"bin\"));\n    candidateDirs.add(path.join(HOME_DIR, \"AppData\", \"Local\", \"Programs\", \"cursor\", \"bin\"));\n  }\n\n  if (binaryPath && path.isAbsolute(binaryPath)) {\n    candidateDirs.add(path.dirname(binaryPath));\n  }\n\n  return Array.from(candidateDirs);\n};\n\nasync function discoverCursorAgentBinary(options: ResolveOptions): Promise<ResolvedBinary> {\n  const additionalSearchDirs = options.additionalSearchDirs ?? [];\n  const logPrefix = options.logPrefix ?? LOG_PREFIX;\n\n  const candidateNames = new Set<string>();\n  if (options.binaryPath) {\n    candidateNames.add(options.binaryPath);\n  }\n  if (CURSOR_BINARY_HINT) {\n    candidateNames.add(CURSOR_BINARY_HINT);\n  }\n  candidateNames.add(\"cursor-agent\");\n  if (process.platform === \"win32\") {\n    candidateNames.add(\"cursor-agent.exe\");\n  }\n\n  for (const name of candidateNames) {\n    if (!name) continue;\n    if (path.isAbsolute(name)) {\n      if (await pathExistsAndExecutable(name)) {\n        return {\n          binary: name,\n          env: null,\n        };\n      }\n      continue;\n    }\n\n    const whichCommand = process.platform === \"win32\" ? \"where\" : \"which\";\n    const lookup = spawnSync(whichCommand, [name], { encoding: \"utf8\" });\n    if (!lookup.error && lookup.status === 0 && lookup.stdout) {\n      const resolvedPath = lookup.stdout.split(/\\r?\\n/).find(Boolean);\n      if (resolvedPath && (await pathExistsAndExecutable(resolvedPath))) {\n        return {\n          binary: resolvedPath,\n          env: null,\n        };\n      }\n    }\n\n    for (const dir of buildCandidateDirs(name, additionalSearchDirs)) {\n      const fullPath = path.join(dir, name);\n      if (await pathExistsAndExecutable(fullPath)) {\n        return {\n          binary: fullPath,\n          env: null,\n        };\n      }\n    }\n  }\n\n  console.error(\n    `${logPrefix} cursor-agent binary not found. Set CURSOR_AGENT_BIN to an absolute path or add cursor-agent to your PATH.`,\n  );\n  throw new Error(\n    \"cursor-agent binary not found. Set CURSOR_AGENT_BIN to an absolute path or add cursor-agent to your PATH.\",\n  );\n}\n\nexport async function resolveCursorAgentBinary(\n  options: ResolveOptions = {},\n): Promise<ResolvedBinary> {\n  if (options.binaryPath) {\n    const normalized = options.binaryPath.trim();\n    if (normalized && (await pathExistsAndExecutable(normalized))) {\n      return {\n        binary: normalized,\n        env: null,\n      };\n    }\n  }\n\n  if (cachedBinary) {\n    return {\n      binary: cachedBinary,\n      env: cachedEnv,\n    };\n  }\n\n  if (!resolvePromise) {\n    resolvePromise = discoverCursorAgentBinary(options)\n      .then((resolved) => {\n        cachedBinary = resolved.binary;\n        const extraDirs: string[] = [\n          ...(options.additionalSearchDirs ?? []),\n          path.dirname(resolved.binary),\n        ];\n        if (HOME_DIR) {\n          extraDirs.push(path.join(HOME_DIR, \".cursor\", \"bin\"));\n          extraDirs.push(path.join(HOME_DIR, \"Library\", \"Application Support\", \"Cursor\", \"bin\"));\n          extraDirs.push(path.join(HOME_DIR, \"AppData\", \"Local\", \"Programs\", \"cursor\", \"bin\"));\n        }\n\n        const existingPath = process.env.PATH ?? \"\";\n        const pathSegments = new Set<string>(\n          existingPath\n            .split(path.delimiter)\n            .map((segment) => segment.trim())\n            .filter(Boolean),\n        );\n\n        for (const dir of extraDirs) {\n          if (dir) {\n            pathSegments.add(dir);\n          }\n        }\n\n        cachedEnv = {\n          ...process.env,\n          PATH: Array.from(pathSegments).join(path.delimiter),\n        };\n\n        return {\n          binary: resolved.binary,\n          env: cachedEnv,\n        };\n      })\n      .catch((error) => {\n        resolvePromise = null;\n        throw error;\n      });\n  }\n\n  return resolvePromise;\n}\n\nexport async function runCursorAgentStream(\n  options: RunOptions,\n  send: (event: StreamEvent) => void,\n) {\n  const logPrefix = options.logPrefix ?? LOG_PREFIX;\n  await new Promise<void>((resolve) => {\n    try {\n      const args = [\n        \"--print\",\n        \"--force\",\n        \"--output-format\",\n        \"stream-json\",\n        \"--stream-partial-output\",\n        \"--model\",\n        options.model,\n        options.prompt,\n      ];\n\n      console.log(`${logPrefix} Spawning cursor-agent`, {\n        command: options.binary,\n        args,\n        cwd: process.cwd(),\n      });\n\n      const child = spawn(options.binary, args, {\n        cwd: process.cwd(),\n        env: options.env ?? process.env,\n        stdio: [\"ignore\", \"pipe\", \"pipe\"],\n      });\n\n      let stdoutBuffer = \"\";\n      let stderrAggregate = \"\";\n      let assistantSummary = \"\";\n      let settled = false;\n\n      const timeoutMs =\n        typeof options.timeoutMs === \"number\"\n          ? options.timeoutMs\n          : Number(process.env.SHIPFLOW_OVERLAY_AGENT_TIMEOUT_MS ?? 4 * 60 * 1000);\n\n      const sendStatus = (message: string) => {\n        if (!message) return;\n        send({ event: \"status\", message });\n      };\n\n      const appendAssistant = (text: string) => {\n        if (!text) return;\n        assistantSummary += text;\n        send({ event: \"assistant\", text });\n      };\n\n      const flushDone = (success: boolean, exitCode: number | null, error?: string) => {\n        send({\n          event: \"done\",\n          success,\n          summary: assistantSummary.trim(),\n          exitCode,\n          error,\n          stderr: stderrAggregate.trim() || undefined,\n        });\n      };\n\n      const processLine = (line: string) => {\n        if (!line.trim()) {\n          return;\n        }\n\n        try {\n          const parsed = JSON.parse(line) as Record<string, unknown>;\n          \n          // Check for error events and fail immediately\n          if (typeof parsed.type === \"string\" && parsed.type === \"error\") {\n            const errorMessage = \n              typeof parsed.message === \"string\" \n                ? parsed.message \n                : typeof parsed.error === \"string\"\n                ? parsed.error\n                : \"Cursor CLI reported an error.\";\n            \n            // Check if it's a model validation error\n            if (errorMessage.toLowerCase().includes(\"cannot use this model\") || \n                errorMessage.toLowerCase().includes(\"available models\")) {\n              if (!settled) {\n                settled = true;\n                clearTimeout(timeoutId);\n                flushDone(false, null, errorMessage);\n                resolve();\n                return;\n              }\n            }\n            \n            sendStatus(`Error: ${errorMessage}`);\n          }\n          \n          const status = describeEvent(parsed);\n          if (status) {\n            const trimmed = status.trim();\n            const isWhitelisted = WHITELISTED_STATUS_MESSAGES.has(trimmed);\n            const isIgnored = IGNORED_STATUS_MESSAGES.has(trimmed);\n            const isLongEnough = trimmed.length >= MIN_STATUS_LENGTH;\n\n            if (!isIgnored && (isWhitelisted || isLongEnough)) {\n              sendStatus(trimmed);\n            }\n          }\n\n          if (typeof parsed.type === \"string\" && parsed.type === \"assistant\") {\n            const text = extractAssistantText(parsed);\n            appendAssistant(text);\n          }\n\n          if (typeof parsed.type === \"string\" && parsed.type === \"result\") {\n            const text = extractAssistantText(parsed);\n            appendAssistant(text);\n          }\n        } catch (error) {\n          console.warn(`${logPrefix} Failed to parse cursor-agent stream line`, {\n            line,\n            error,\n          });\n          sendStatus(line);\n        }\n      };\n\n      const timeoutId = setTimeout(() => {\n        if (settled) return;\n        settled = true;\n\n        console.warn(`${logPrefix} cursor-agent exceeded timeout; terminating process`, {\n          timeoutMs,\n        });\n\n        sendStatus(`Cursor CLI timed out after ${timeoutMs}ms; terminating process.`);\n\n        try {\n          child.kill(\"SIGTERM\");\n        } catch (killError) {\n          console.warn(`${logPrefix} Failed to terminate cursor-agent process`, killError);\n        }\n\n        flushDone(false, null, `Cursor CLI timed out after ${timeoutMs}ms.`);\n        resolve();\n      }, timeoutMs);\n\n      child.stdout.on(\"data\", (chunk) => {\n        const text = chunk.toString();\n        stdoutBuffer += text;\n\n        let newlineIndex = stdoutBuffer.indexOf(\"\\n\");\n        while (newlineIndex !== -1) {\n          const line = stdoutBuffer.slice(0, newlineIndex);\n          stdoutBuffer = stdoutBuffer.slice(newlineIndex + 1);\n          processLine(line);\n          newlineIndex = stdoutBuffer.indexOf(\"\\n\");\n        }\n      });\n\n      child.stderr.on(\"data\", (chunk) => {\n        const text = chunk.toString();\n        stderrAggregate += text;\n        \n        // Check for model validation errors in stderr\n        const lowerText = text.toLowerCase();\n        if ((lowerText.includes(\"cannot use this model\") || \n             lowerText.includes(\"available models\")) && \n            !settled) {\n          settled = true;\n          clearTimeout(timeoutId);\n          const errorMessage = text.trim();\n          flushDone(false, null, errorMessage);\n          resolve();\n          return;\n        }\n        \n        for (const line of text.split(/\\r?\\n/).map((entry: string) => entry.trim()).filter(Boolean)) {\n          sendStatus(`[stderr] ${line}`);\n        }\n        console.error(`${logPrefix} cursor-agent stderr:`, text);\n      });\n\n      child.on(\"error\", (error) => {\n        if (settled) return;\n        settled = true;\n        clearTimeout(timeoutId);\n        console.error(`${logPrefix} cursor-agent failed to start`, error);\n        flushDone(false, null, error instanceof Error ? error.message : \"Failed to start Cursor CLI.\");\n        resolve();\n      });\n\n      child.on(\"close\", (exitCode) => {\n        if (settled) return;\n        settled = true;\n        clearTimeout(timeoutId);\n\n        if (stdoutBuffer.trim()) {\n          processLine(stdoutBuffer);\n          stdoutBuffer = \"\";\n        }\n\n        console.log(`${logPrefix} cursor-agent exited`, { exitCode });\n\n        if (exitCode === 0) {\n          flushDone(true, exitCode ?? 0);\n        } else {\n          const error =\n            stderrAggregate.trim() ||\n            `Cursor CLI exited with status ${exitCode ?? \"unknown\"}. Check server logs for details.`;\n          flushDone(false, exitCode ?? null, error);\n        }\n\n        resolve();\n      });\n    } catch (error) {\n      console.error(`${logPrefix} Unexpected error launching cursor-agent`, error);\n      send({\n        event: \"done\",\n        success: false,\n        summary: \"\",\n        exitCode: null,\n        error: error instanceof Error ? error.message : \"Unexpected error launching Cursor CLI.\",\n      });\n      resolve();\n    }\n  });\n}\n\n\n\n","import { createNextHandler, type ShipflowOverlayServerOptions } from \"./server/createNextHandler\";\n\ntype NextConfig = Record<string, unknown>;\n\nexport type ShipflowOverlayNextOptions = {\n  enableInProduction?: boolean;\n  reactGrabUrl?: string;\n  logClipboardEndpoint?: string;\n};\n\nexport function withShipflowOverlay<T extends NextConfig = NextConfig>(\n  config: T = {} as T,\n  options: ShipflowOverlayNextOptions = {},\n): T & NextConfig {\n  const enabled =\n    options.enableInProduction || process.env.NODE_ENV === \"development\";\n\n  const env: Record<string, string | undefined> = {\n    ...(config.env as Record<string, string | undefined> | undefined),\n    SHIPFLOW_OVERLAY_ENABLED: enabled ? \"true\" : \"false\",\n  };\n\n  if (options.reactGrabUrl) {\n    env.SHIPFLOW_OVERLAY_REACT_GRAB_URL = options.reactGrabUrl;\n  }\n\n  if (options.logClipboardEndpoint) {\n    env.SHIPFLOW_OVERLAY_LOG_ENDPOINT = options.logClipboardEndpoint;\n  }\n\n  const existingTranspile = Array.isArray(config.transpilePackages)\n    ? config.transpilePackages\n    : [];\n  const transpilePackages = Array.from(\n    new Set([...existingTranspile, \"@shipflow/overlay\"]),\n  );\n\n  return {\n    ...config,\n    env,\n    transpilePackages,\n  };\n}\n\nexport { createNextHandler, type ShipflowOverlayServerOptions };\nexport { createUndoHandler, type ShipflowUndoServerOptions } from \"./server/createUndoHandler\";\n\n\n\n","import type { NextRequest } from \"next/server\";\nimport { NextResponse } from \"next/server\";\n\nimport type { StreamEvent } from \"../runtime/types\";\n// Import constants, including STREAM_HEADERS\nimport { STREAM_HEADERS } from \"../runtime/constants\";\nimport { undoManager } from \"./undoManager\";\n\nexport type ShipflowOverlayRequestPayload = {\n  filePath: string | null;\n  htmlFrame: string | null;\n  stackTrace: string | null;\n  instruction: string;\n  model?: string;\n};\n\nexport type ShipflowOverlayServerOptions = {\n  cursorAgentBinary?: string;\n  additionalSearchDirs?: string[];\n  defaultModel?: string;\n  allowInProduction?: boolean;\n  timeoutMs?: number;\n  logPrefix?: string;\n};\n\nconst DEFAULT_MODEL = \"composer-1\";\n\n// Edge-runtime-compatible path utilities (no Node.js path module required)\nconst isAbsolutePath = (p: string): boolean => {\n  // Unix absolute path\n  if (p.startsWith(\"/\")) return true;\n  // Windows absolute path (e.g., C:\\ or C:/)\n  if (/^[A-Za-z]:[\\\\/]/.test(p)) return true;\n  return false;\n};\n\nconst normalizeSeparators = (p: string): string => p.replace(/\\\\/g, \"/\");\n\nconst getRelativePath = (from: string, to: string): string => {\n  const fromParts = normalizeSeparators(from).split(\"/\").filter(Boolean);\n  const toParts = normalizeSeparators(to).split(\"/\").filter(Boolean);\n\n  // Find common prefix length\n  let commonLength = 0;\n  const minLength = Math.min(fromParts.length, toParts.length);\n  for (let i = 0; i < minLength; i++) {\n    if (fromParts[i] === toParts[i]) {\n      commonLength++;\n    } else {\n      break;\n    }\n  }\n\n  // Build relative path\n  const upCount = fromParts.length - commonLength;\n  const downParts = toParts.slice(commonLength);\n  const relativeParts = [...Array(upCount).fill(\"..\"), ...downParts];\n\n  return relativeParts.join(\"/\") || \".\";\n};\n\n// Multiple patterns to extract file paths from various stack trace formats\nconst STACK_TRACE_PATTERNS = [\n  // Format: \"in Component (path/to/file.tsx:10:5)\" or \"at Component (path/to/file.tsx:10:5)\"\n  /\\b(?:in|at)\\s+\\S+\\s*\\(([^()]+?\\.(?:[jt]sx?|mdx?))(?::\\d+)*\\)/gi,\n  // Format: \"in path/to/file.tsx\" or \"at path/to/file.tsx\"\n  /\\b(?:in|at)\\s+((?:[A-Za-z]:)?[^\\s:()]+?\\.(?:[jt]sx?|mdx?))/gi,\n  // Format: just \"(path/to/file.tsx:10:5)\" in parentheses\n  /\\(([^()]+?\\.(?:[jt]sx?|mdx?))(?::\\d+)*\\)/gi,\n  // Format: bare path like \"app/page.tsx\" without surrounding context\n  /(?:^|\\s)((?:\\.\\/)?(?:[A-Za-z]:)?[^\\s:()]+?\\.(?:[jt]sx?|mdx?))/gim,\n];\n\nconst normalizeFilePath = (filePath: string | null) => {\n  if (!filePath) return null;\n  const trimmed = filePath.trim();\n  if (!trimmed) return null;\n\n  const webpackPrefix = \"webpack-internal:///\";\n  const filePrefix = \"file://\";\n  let sanitized = trimmed;\n  if (sanitized.startsWith(webpackPrefix)) {\n    sanitized = sanitized.slice(webpackPrefix.length);\n  }\n  if (sanitized.startsWith(filePrefix)) {\n    sanitized = sanitized.slice(filePrefix.length);\n  }\n  if (sanitized.startsWith(\"./\")) {\n    sanitized = sanitized.slice(2);\n  }\n\n  if (!sanitized) {\n    return null;\n  }\n\n  const cwd = process.cwd();\n  if (pathIsAbsoluteSafe(sanitized)) {\n    const relative = relativeSafe(cwd, sanitized);\n    return relative.startsWith(\"..\") ? sanitized : relative;\n  }\n\n  return sanitized;\n};\n\nconst pathIsAbsoluteSafe = (target: string) => {\n  try {\n    return isAbsolutePath(target);\n  } catch {\n    return false;\n  }\n};\n\nconst relativeSafe = (from: string, to: string) => {\n  try {\n    return getRelativePath(from, to);\n  } catch {\n    return to;\n  }\n};\n\nconst extractFilePathFromStackTrace = (stackTrace: string | null) => {\n  if (!stackTrace) return null;\n\n  // Try each pattern in order of specificity\n  for (const pattern of STACK_TRACE_PATTERNS) {\n    pattern.lastIndex = 0;\n    let match: RegExpExecArray | null;\n\n    while ((match = pattern.exec(stackTrace))) {\n      const rawCandidate = match[1];\n      if (typeof rawCandidate !== \"string\") {\n        continue;\n      }\n\n      let candidate = rawCandidate.trim();\n      if (!candidate) {\n        continue;\n      }\n\n      // Skip node_modules paths\n      if (candidate.includes(\"node_modules/\") || candidate.includes(\"node_modules\\\\\")) {\n        continue;\n      }\n\n      // Skip URLs\n      if (candidate.includes(\"://\")) {\n        continue;\n      }\n\n      // Clean up webpack prefixes\n      if (candidate.startsWith(\"webpack-internal:///\")) {\n        candidate = candidate.slice(\"webpack-internal:///\".length);\n      }\n\n      // Clean up relative path prefix\n      if (candidate.startsWith(\"./\")) {\n        candidate = candidate.slice(2);\n      }\n\n      // Strip line/column numbers at the end (e.g., \":10:5\")\n      candidate = candidate.replace(/:\\d+(?::\\d+)?$/, \"\");\n\n      if (!candidate) {\n        continue;\n      }\n\n      return candidate;\n    }\n  }\n\n  return null;\n};\n\nconst extractComponentNames = (stackTrace: string | null): string[] => {\n  if (!stackTrace) return [];\n  // Match \"at ComponentName (Server)\" or \"in ComponentName (Server)\" - PascalCase components only\n  const matches = stackTrace.matchAll(/\\b(?:at|in)\\s+([A-Z][a-zA-Z0-9]*)\\s*\\(Server\\)/g);\n  return [...matches].map((m) => m[1]).filter(Boolean);\n};\n\nconst buildPrompt = (\n  filePath: string | null,\n  htmlFrame: string | null,\n  stackTrace: string | null,\n  instruction: string,\n) => {\n  const lines: string[] = [];\n\n  if (filePath) {\n    lines.push(`Open ${filePath}.`);\n    lines.push(\"Target the element matching this HTML:\");\n    lines.push(htmlFrame ?? \"(no HTML frame provided)\");\n    lines.push(\"\");\n    lines.push(\"and the component stack:\");\n    lines.push(stackTrace ?? \"(no component stack provided)\");\n  } else {\n    // Fallback for RSC or when file path cannot be determined\n    lines.push(\"Find the file containing the component that renders this HTML:\");\n    lines.push(htmlFrame ?? \"(no HTML frame provided)\");\n    lines.push(\"\");\n    lines.push(\"Component stack (use component names to locate the file):\");\n    lines.push(stackTrace ?? \"(no component stack provided)\");\n\n    const componentNames = extractComponentNames(stackTrace);\n    if (componentNames.length > 0) {\n      lines.push(\"\");\n      lines.push(`Look for files defining these components: ${componentNames.join(\", \")}`);\n    }\n  }\n\n  lines.push(\"\");\n  lines.push(`User request: ${instruction}`);\n  return lines.join(\"\\n\");\n};\n\nconst stripNullish = <T extends Record<string, unknown>>(record: T): T =>\n  Object.fromEntries(\n    Object.entries(record).filter(([, value]) => value !== undefined && value !== null),\n  ) as T;\n\nconst isEnabled = (options: ShipflowOverlayServerOptions): boolean => {\n  if (options.allowInProduction) {\n    return true;\n  }\n  const envFlag = process.env.SHIPFLOW_OVERLAY_ENABLED;\n  if (envFlag && [\"true\", \"1\", \"on\", \"yes\"].includes(envFlag.toLowerCase())) {\n    return true;\n  }\n  return process.env.NODE_ENV === \"development\";\n};\n\nexport function createNextHandler(options: ShipflowOverlayServerOptions = {}) {\n  const logPrefix = options.logPrefix ?? \"[shipflow-overlay]\";\n\n  return async function handler(request: NextRequest) {\n    if (!isEnabled(options)) {\n      return NextResponse.json(\n        { error: \"Shipflow overlay workflow is only available in development.\" },\n        { status: 403 },\n      );\n    }\n\n    let payload: ShipflowOverlayRequestPayload;\n    try {\n      payload = (await request.json()) as ShipflowOverlayRequestPayload;\n    } catch {\n      return NextResponse.json({ error: \"Invalid JSON payload.\" }, { status: 400 });\n    }\n\n    const instruction = payload.instruction?.trim();\n    if (!instruction) {\n      return NextResponse.json({ error: \"Instruction is required.\" }, { status: 400 });\n    }\n\n    const directFilePath = normalizeFilePath(payload.filePath);\n    const derivedFilePath =\n      directFilePath ??\n      (payload.filePath\n        ? null\n        : normalizeFilePath(extractFilePathFromStackTrace(payload.stackTrace)));\n    const normalizedFilePath = derivedFilePath;\n\n    if (!normalizedFilePath) {\n      const truncatedStack = payload.stackTrace?.slice(0, 200) ?? \"(none)\";\n      console.warn(\n        `${logPrefix} No file path found, using fallback prompt. stackTrace snippet: ${truncatedStack}`,\n      );\n    }\n\n    // buildPrompt handles null filePath with a discovery-focused fallback prompt\n    const prompt = buildPrompt(normalizedFilePath, payload.htmlFrame, payload.stackTrace, instruction);\n    const model = payload.model?.trim() || options.defaultModel || DEFAULT_MODEL;\n\n    try {\n      // Dynamically import the cursor agent implementation to avoid bundling Node.js dependencies\n      // (child_process, fs) in the initial bundle. This helps prevent errors in Edge environments\n      // where these modules are not available, even if this handler is only used in Node.js routes.\n      const { resolveCursorAgentBinary, runCursorAgentStream } = await import(\"./cursorAgent\");\n\n      const resolved = await resolveCursorAgentBinary(\n        stripNullish({\n          binaryPath: options.cursorAgentBinary,\n          additionalSearchDirs: options.additionalSearchDirs,\n          logPrefix,\n        }),\n      );\n\n      // Create undo session and capture workspace state\n      const cwd = process.cwd();\n      const sessionId = undoManager.createSession(instruction, normalizedFilePath);\n      \n      try {\n        await undoManager.captureWorkspace(sessionId, cwd);\n      } catch (error) {\n        console.warn(`${logPrefix} Failed to capture workspace for undo:`, error);\n      }\n\n      const encoder = new TextEncoder();\n\n      const stream = new ReadableStream({\n        async start(controller) {\n          const state = { isClosed: false };\n\n          const send = (event: StreamEvent) => {\n            if (state.isClosed) {\n              return;\n            }\n            try {\n              controller.enqueue(encoder.encode(`${JSON.stringify(event)}\\n`));\n            } catch (error) {\n              if (\n                error instanceof TypeError &&\n                (error.message.includes(\"closed\") || error.message.includes(\"Invalid state\"))\n              ) {\n                state.isClosed = true;\n              }\n            }\n          };\n\n          request.signal.addEventListener(\"abort\", () => {\n            state.isClosed = true;\n            try {\n              controller.close();\n            } catch {\n              // ignore\n            }\n          });\n\n          // Send session ID for undo support\n          send({ event: \"session\", sessionId });\n          send({ event: \"status\", message: \"Understanding user intent\" });\n\n          try {\n            await runCursorAgentStream(\n              {\n                binary: resolved.binary,\n                model,\n                prompt,\n                timeoutMs: options.timeoutMs,\n                logPrefix,\n                env: resolved.env,\n              },\n              send,\n            );\n          } catch (error) {\n            if (state.isClosed) {\n              return;\n            }\n            console.error(`${logPrefix} Failed during Cursor CLI streaming`, error);\n            send({\n              event: \"done\",\n              success: false,\n              summary: \"\",\n              exitCode: null,\n              error:\n                error instanceof Error\n                  ? error.message\n                  : \"Unexpected error streaming from Cursor CLI.\",\n            });\n          } finally {\n            if (!state.isClosed) {\n              try {\n                controller.close();\n              } catch {\n                // ignore\n              }\n              state.isClosed = true;\n            }\n          }\n        },\n      });\n\n      return new NextResponse(stream, {\n        headers: STREAM_HEADERS,\n      });\n    } catch (error) {\n      console.error(`${logPrefix} Failed to run cursor-agent`, error);\n      return NextResponse.json(\n        {\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Failed to invoke Cursor CLI. Ensure cursor-agent is installed and available on PATH.\",\n        },\n        { status: 500 },\n      );\n    }\n  };\n}\n","export const DEFAULT_STATUS_SEQUENCE = [\n  \"Thinking\",\n  \"Planning next moves\",\n  \"Updating UI\",\n] as const;\n\nexport const DEFAULT_MODEL_OPTIONS = [\n  { value: \"composer-1\", label: \"Composer 1\" },\n  { value: \"gemini-3-pro\", label: \"Gemini 3 Pro\" },\n  { value: \"opus-4.5\", label: \"Opus 4.5\" },\n  { value: \"gpt-5.1-codex-high\", label: \"GPT-5.1 Codex High\" },\n] as const;\n\nexport const STREAM_HEADERS = {\n  \"Content-Type\": \"application/x-ndjson; charset=utf-8\",\n  \"Cache-Control\": \"no-cache, no-transform\",\n};\n","import { readFile, writeFile, unlink, readdir, stat } from \"fs/promises\";\nimport { join, relative, extname } from \"path\";\nimport { randomUUID } from \"crypto\";\n\nconst LOG_PREFIX = \"[shipflow-undo]\";\n\n// File extensions to capture\nconst SOURCE_EXTENSIONS = new Set([\n  \".ts\",\n  \".tsx\",\n  \".js\",\n  \".jsx\",\n  \".mjs\",\n  \".cjs\",\n  \".json\",\n  \".css\",\n  \".scss\",\n  \".sass\",\n  \".less\",\n  \".md\",\n  \".mdx\",\n  \".html\",\n]);\n\n// Directories to skip\nconst IGNORE_DIRS = new Set([\n  \"node_modules\",\n  \".next\",\n  \".git\",\n  \"dist\",\n  \"build\",\n  \".turbo\",\n  \".vercel\",\n  \"coverage\",\n  \".nyc_output\",\n  \"__pycache__\",\n  \".cache\",\n]);\n\n// File patterns to skip\nconst IGNORE_PATTERNS = [/\\.min\\./, /\\.d\\.ts$/, /\\.map$/];\n\n// Limits\nconst MAX_FILE_SIZE = 1 * 1024 * 1024; // 1MB per file\nconst MAX_SESSION_SIZE = 50 * 1024 * 1024; // 50MB total per session\nconst MAX_SESSIONS = 5;\n\nexport interface UndoSession {\n  id: string;\n  timestamp: number;\n  instruction: string;\n  filePath: string | null;\n  snapshots: Map<string, string | null>; // path -> content (null = didn't exist)\n  totalSize: number;\n}\n\nexport interface RestoreResult {\n  success: boolean;\n  restored: string[];\n  deleted: string[];\n  error?: string;\n}\n\nclass UndoManager {\n  private sessions: Map<string, UndoSession> = new Map();\n  private sessionOrder: string[] = []; // For FIFO eviction\n  private latestSessionId: string | null = null;\n\n  /**\n   * Create a new undo session\n   */\n  createSession(instruction: string, filePath: string | null): string {\n    const id = randomUUID();\n    const session: UndoSession = {\n      id,\n      timestamp: Date.now(),\n      instruction,\n      filePath,\n      snapshots: new Map(),\n      totalSize: 0,\n    };\n\n    this.sessions.set(id, session);\n    this.sessionOrder.push(id);\n    this.latestSessionId = id;\n\n    // Evict old sessions if we exceed the limit\n    while (this.sessionOrder.length > MAX_SESSIONS) {\n      const oldestId = this.sessionOrder.shift();\n      if (oldestId) {\n        this.sessions.delete(oldestId);\n        console.log(`${LOG_PREFIX} Evicted old session: ${oldestId}`);\n      }\n    }\n\n    console.log(`${LOG_PREFIX} Created session: ${id}`);\n    return id;\n  }\n\n  /**\n   * Capture the current state of all source files in the workspace\n   */\n  async captureWorkspace(sessionId: string, cwd: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n\n    console.log(`${LOG_PREFIX} Capturing workspace: ${cwd}`);\n    const startTime = Date.now();\n    let fileCount = 0;\n\n    try {\n      await this.walkDirectory(cwd, cwd, session);\n      fileCount = session.snapshots.size;\n    } catch (error) {\n      console.error(`${LOG_PREFIX} Error capturing workspace:`, error);\n      throw error;\n    }\n\n    const duration = Date.now() - startTime;\n    console.log(\n      `${LOG_PREFIX} Captured ${fileCount} files (${(session.totalSize / 1024).toFixed(1)}KB) in ${duration}ms`\n    );\n  }\n\n  /**\n   * Recursively walk directory and capture files\n   */\n  private async walkDirectory(\n    dir: string,\n    rootDir: string,\n    session: UndoSession\n  ): Promise<void> {\n    let entries;\n    try {\n      entries = await readdir(dir, { withFileTypes: true });\n    } catch {\n      // Directory might not be readable, skip it\n      return;\n    }\n\n    for (const entry of entries) {\n      const fullPath = join(dir, entry.name);\n\n      if (entry.isDirectory()) {\n        // Skip ignored directories\n        if (IGNORE_DIRS.has(entry.name)) {\n          continue;\n        }\n        await this.walkDirectory(fullPath, rootDir, session);\n      } else if (entry.isFile()) {\n        await this.captureFile(fullPath, rootDir, session);\n      }\n    }\n  }\n\n  /**\n   * Capture a single file if it matches our criteria\n   */\n  private async captureFile(\n    filePath: string,\n    rootDir: string,\n    session: UndoSession\n  ): Promise<void> {\n    // Check extension\n    const ext = extname(filePath).toLowerCase();\n    if (!SOURCE_EXTENSIONS.has(ext)) {\n      return;\n    }\n\n    // Check ignore patterns\n    const relativePath = relative(rootDir, filePath);\n    if (IGNORE_PATTERNS.some((pattern) => pattern.test(relativePath))) {\n      return;\n    }\n\n    // Check file size\n    let stats;\n    try {\n      stats = await stat(filePath);\n    } catch {\n      return;\n    }\n\n    if (stats.size > MAX_FILE_SIZE) {\n      console.log(`${LOG_PREFIX} Skipping large file: ${relativePath} (${(stats.size / 1024 / 1024).toFixed(1)}MB)`);\n      return;\n    }\n\n    // Check session size limit\n    if (session.totalSize + stats.size > MAX_SESSION_SIZE) {\n      console.warn(`${LOG_PREFIX} Session size limit reached, stopping capture`);\n      return;\n    }\n\n    // Read and store file content\n    try {\n      const content = await readFile(filePath, \"utf-8\");\n      session.snapshots.set(filePath, content);\n      session.totalSize += stats.size;\n    } catch (error) {\n      console.warn(`${LOG_PREFIX} Failed to read file: ${relativePath}`, error);\n    }\n  }\n\n  /**\n   * Restore workspace to the state captured in the session\n   */\n  async restoreSession(sessionId: string): Promise<RestoreResult> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      return {\n        success: false,\n        restored: [],\n        deleted: [],\n        error: `Session not found: ${sessionId}`,\n      };\n    }\n\n    console.log(`${LOG_PREFIX} Restoring session: ${sessionId}`);\n    const restored: string[] = [];\n    const deleted: string[] = [];\n    const errors: string[] = [];\n\n    for (const [filePath, originalContent] of session.snapshots) {\n      try {\n        if (originalContent === null) {\n          // File didn't exist before - delete it if it exists now\n          try {\n            await unlink(filePath);\n            deleted.push(filePath);\n            console.log(`${LOG_PREFIX} Deleted: ${filePath}`);\n          } catch {\n            // File might not exist anymore, that's fine\n          }\n        } else {\n          // Check if file has changed\n          let currentContent: string | null = null;\n          try {\n            currentContent = await readFile(filePath, \"utf-8\");\n          } catch {\n            // File might have been deleted\n          }\n\n          if (currentContent !== originalContent) {\n            await writeFile(filePath, originalContent, \"utf-8\");\n            restored.push(filePath);\n            console.log(`${LOG_PREFIX} Restored: ${filePath}`);\n          }\n        }\n      } catch (error) {\n        const msg = `Failed to restore ${filePath}: ${error instanceof Error ? error.message : String(error)}`;\n        errors.push(msg);\n        console.error(`${LOG_PREFIX} ${msg}`);\n      }\n    }\n\n    // Also check for new files created by the agent that weren't in our snapshot\n    // We need to detect these by comparing with current state\n    // For now, we only restore files we knew about\n\n    // Remove the session after restore\n    this.sessions.delete(sessionId);\n    const idx = this.sessionOrder.indexOf(sessionId);\n    if (idx !== -1) {\n      this.sessionOrder.splice(idx, 1);\n    }\n    if (this.latestSessionId === sessionId) {\n      this.latestSessionId = this.sessionOrder[this.sessionOrder.length - 1] ?? null;\n    }\n\n    console.log(\n      `${LOG_PREFIX} Restore complete: ${restored.length} restored, ${deleted.length} deleted`\n    );\n\n    return {\n      success: errors.length === 0,\n      restored,\n      deleted,\n      error: errors.length > 0 ? errors.join(\"; \") : undefined,\n    };\n  }\n\n  /**\n   * Get the latest session ID\n   */\n  getLatestSessionId(): string | null {\n    return this.latestSessionId;\n  }\n\n  /**\n   * Get session info (without full snapshots)\n   */\n  getSessionInfo(sessionId: string): Omit<UndoSession, \"snapshots\"> | null {\n    const session = this.sessions.get(sessionId);\n    if (!session) return null;\n\n    return {\n      id: session.id,\n      timestamp: session.timestamp,\n      instruction: session.instruction,\n      filePath: session.filePath,\n      totalSize: session.totalSize,\n    };\n  }\n\n  /**\n   * List all sessions\n   */\n  listSessions(): Array<Omit<UndoSession, \"snapshots\">> {\n    return this.sessionOrder.map((id) => {\n      const session = this.sessions.get(id)!;\n      return {\n        id: session.id,\n        timestamp: session.timestamp,\n        instruction: session.instruction,\n        filePath: session.filePath,\n        totalSize: session.totalSize,\n      };\n    });\n  }\n\n  /**\n   * Track a new file that was created during agent execution\n   * Call this when we detect a file was created that wasn't in our initial snapshot\n   */\n  trackNewFile(sessionId: string, filePath: string): void {\n    const session = this.sessions.get(sessionId);\n    if (!session) return;\n\n    if (!session.snapshots.has(filePath)) {\n      session.snapshots.set(filePath, null); // null means file didn't exist\n      console.log(`${LOG_PREFIX} Tracking new file: ${filePath}`);\n    }\n  }\n}\n\n// Singleton instance\nexport const undoManager = new UndoManager();\n","import type { NextRequest } from \"next/server\";\nimport { NextResponse } from \"next/server\";\n\nimport { undoManager } from \"./undoManager\";\n\nexport type ShipflowUndoRequestPayload = {\n  sessionId?: string;\n};\n\nexport type ShipflowUndoServerOptions = {\n  allowInProduction?: boolean;\n  logPrefix?: string;\n};\n\nconst isEnabled = (options: ShipflowUndoServerOptions): boolean => {\n  if (options.allowInProduction) {\n    return true;\n  }\n  const envFlag = process.env.SHIPFLOW_OVERLAY_ENABLED;\n  if (envFlag && [\"true\", \"1\", \"on\", \"yes\"].includes(envFlag.toLowerCase())) {\n    return true;\n  }\n  return process.env.NODE_ENV === \"development\";\n};\n\nexport function createUndoHandler(options: ShipflowUndoServerOptions = {}) {\n  const logPrefix = options.logPrefix ?? \"[shipflow-undo]\";\n\n  return async function handler(request: NextRequest) {\n    if (!isEnabled(options)) {\n      return NextResponse.json(\n        { error: \"Shipflow undo is only available in development.\" },\n        { status: 403 }\n      );\n    }\n\n    let payload: ShipflowUndoRequestPayload;\n    try {\n      payload = (await request.json()) as ShipflowUndoRequestPayload;\n    } catch {\n      // If no body, use latest session\n      payload = {};\n    }\n\n    const sessionId = payload.sessionId ?? undoManager.getLatestSessionId();\n\n    if (!sessionId) {\n      return NextResponse.json(\n        { error: \"No undo session available.\" },\n        { status: 404 }\n      );\n    }\n\n    console.log(`${logPrefix} Undo requested for session: ${sessionId}`);\n\n    try {\n      const result = await undoManager.restoreSession(sessionId);\n\n      if (!result.success) {\n        return NextResponse.json(\n          {\n            success: false,\n            error: result.error ?? \"Failed to restore session.\",\n            restored: result.restored,\n            deleted: result.deleted,\n          },\n          { status: 500 }\n        );\n      }\n\n      return NextResponse.json({\n        success: true,\n        restored: result.restored,\n        deleted: result.deleted,\n        message: `Restored ${result.restored.length} file(s), deleted ${result.deleted.length} file(s).`,\n      });\n    } catch (error) {\n      console.error(`${logPrefix} Undo failed:`, error);\n      return NextResponse.json(\n        {\n          success: false,\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Unexpected error during undo.\",\n        },\n        { status: 500 }\n      );\n    }\n  };\n}\n\n// Re-export undoManager for advanced use cases\nexport { undoManager } from \"./undoManager\";\n"],"mappings":"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","names":["STREAM_HEADERS","_a","_b","LOG_PREFIX","path","import_promises","import_path","fsConstants","_a","relative","_a","_b","resolveCursorAgentBinary","runCursorAgentStream","import_server","isEnabled","_a","_b"]}